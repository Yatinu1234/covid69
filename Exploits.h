#pragma once
#include "includes.h"

// No Reload Values
// Orignal
float originalReloadTime = 0.0f;
float originalReloadScale = 0.0f;
float originalChargeDownTime = 0.0f;
// No Recoil Values
// Orignal
float originalRecoilVert = 0.0f;
float originalRecoilHoriz = 0.0f;
float originalRecoilDownsightsMultiplier = 0.0f;
//
// No Spread Values
// Orignal
float originalSpread = 0.0f;
float originalSpreadDownsights = 0.0f;
float originalStandingStillSpreadMultiplier = 0.0f;
float originalAthenaJumpingFallingSpreadMultiplier = 0.0f;
float originalAthenaCrouchingSpreadMultiplier = 0.0f;
float originalAthenaSprintingSpreadMultiplier = 0.0f;
float originalMinSpeedForSpreadMultiplier = 0.0f;
float originalMaxSpeedForSpreadMultiplier = 0.0f;
//

PVOID localPlayerWeapon = 0;

static void Rapid(float time)
{
	uint64_t CurrentWeapon = 0;
	float i = 0;
	float c = 0;

	CurrentWeapon = *(uint64_t*)(LocalPawn + Offsets::CurrentWeapon);

	if (CurrentWeapon) {
		i = *(float*)(CurrentWeapon + Offsets::LastFireTime);
		c = *(float*)(CurrentWeapon + Offsets::LastFireTimeVerified);
		*(float*)(CurrentWeapon + Offsets::LastFireTime) = i + c - time;

		return;
	}
}

inline bool __fastcall SetCurrentSpread(__int64 CurrentWeapon, float spread)
{
	unsigned __int8* currentWeapon;
	__int64 v9;
	int v10;
	double v29;
	float result;

	currentWeapon = (unsigned __int8*)CurrentWeapon;
	v9 = currentWeapon[0xEAE];
	v10 = currentWeapon[0xEAF] | 0x4C000001;

	if (!v9 || v10)
	{
		return 0;
	}

	v29 = *(DWORD*)&currentWeapon[4 * v9 + 0xE9E];

	result = *(float*)(v10 ^ (int)v29) = spread;

	return result;
}

VOID CalcAngle(float* src, float* dst, float* angles);
VOID ToMatrixWithScale(float* in, float out[4][4]);
VOID GetBoneLocation(float compMatrix[4][4], PVOID bones, DWORD index, float out[3]);

float Normalize(float angle) {
	float a = (float)fmod(fmod(angle, 360.0) + 360.0, 360.0);
	if (a > 180.0f) {
		a -= 360.0f;
	}
	return a;
}

VOID CalcAngle(float* src, float* dst, float* angles) {
	float rel[3] = {
		dst[0] - src[0],
		dst[1] - src[1],
		dst[2] - src[2],
	};

	auto dist = sqrtf(rel[0] * rel[0] + rel[1] * rel[1] + rel[2] * rel[2]);
	auto yaw = atan2f(rel[1], rel[0]) * (180.0f / PI);
	auto pitch = (-((acosf((rel[2] / dist)) * 180.0f / PI) - 90.0f));

	angles[0] = Normalize(pitch);
	angles[1] = Normalize(yaw);
}

void ToMatrixWithScale(float* in, float out[4][4]) {
	auto* rotation = &in[0];
	auto* translation = &in[4];
	auto* scale = &in[8];

	out[3][0] = translation[0];
	out[3][1] = translation[1];
	out[3][2] = translation[2];

	auto x2 = rotation[0] + rotation[0];
	auto y2 = rotation[1] + rotation[1];
	auto z2 = rotation[2] + rotation[2];

	auto xx2 = rotation[0] * x2;
	auto yy2 = rotation[1] * y2;
	auto zz2 = rotation[2] * z2;
	out[0][0] = (1.0f - (yy2 + zz2)) * scale[0];
	out[1][1] = (1.0f - (xx2 + zz2)) * scale[1];
	out[2][2] = (1.0f - (xx2 + yy2)) * scale[2];

	auto yz2 = rotation[1] * z2;
	auto wx2 = rotation[3] * x2;
	out[2][1] = (yz2 - wx2) * scale[2];
	out[1][2] = (yz2 + wx2) * scale[1];

	auto xy2 = rotation[0] * y2;
	auto wz2 = rotation[3] * z2;
	out[1][0] = (xy2 - wz2) * scale[1];
	out[0][1] = (xy2 + wz2) * scale[0];

	auto xz2 = rotation[0] * z2;
	auto wy2 = rotation[3] * y2;
	out[2][0] = (xz2 + wy2) * scale[2];
	out[0][2] = (xz2 - wy2) * scale[0];

	out[0][3] = 0.0f;
	out[1][3] = 0.0f;
	out[2][3] = 0.0f;
	out[3][3] = 1.0f;
}

void MultiplyMatrices(float a[4][4], float b[4][4], float out[4][4]) {
	for (auto r = 0; r < 4; ++r) {
		for (auto c = 0; c < 4; ++c) {
			auto sum = 0.0f;

			for (auto i = 0; i < 4; ++i) {
				sum += a[r][i] * b[i][c];
			}

			out[r][c] = sum;
		}
	}
}

VOID GetBoneLocation(float compMatrix[4][4], PVOID bones, DWORD index, float out[3]) {
	float boneMatrix[4][4];
	ToMatrixWithScale((float*)((PBYTE)bones + (index * 0x30)), boneMatrix);

	float result[4][4];
	MultiplyMatrices(boneMatrix, compMatrix, result);

	out[0] = result[3][0];
	out[1] = result[3][1];
	out[2] = result[3][2];
}


bool GetWeakSpotPos(PVOID pawn, FVector& out)
{
	if (!pawn) {
		return FALSE;
	}

	auto mesh = ReadPointer(pawn, Offsets::Mesh);
	if (!mesh) {
		return FALSE;
	}

	auto bones = ReadPointer(mesh, Offsets::StaticMesh);
	if (!bones) bones = ReadPointer(mesh, Offsets::StaticMesh + 0x10);
	if (!bones) {
		return FALSE;
	}

	float compMatrix[4][4] = { 0 };
	ToMatrixWithScale(reinterpret_cast<float*>(reinterpret_cast<PBYTE>(mesh) + Offsets::ComponentToWorld), compMatrix);

	if (Settings.AimPos == 1)
		GetBoneLocation(compMatrix, bones, 66, &out.X);
	else if (Settings.AimPos == 2)
		GetBoneLocation(compMatrix, bones, 5, &out.X);
	else if (Settings.AimPos == 3)
		GetBoneLocation(compMatrix, bones, 2, &out.X);
	else // which is impossible.
		GetBoneLocation(compMatrix, bones, 66, &out.X);
	return TRUE;
}

bool GetTargetHead(FVector& out)
{
	if (!entityx) {
		return FALSE;
	}

	auto mesh = ReadPointer(entityx, Offsets::Mesh);
	if (!mesh) {
		return FALSE;
	}

	auto bones = ReadPointer(mesh, Offsets::StaticMesh);
	if (!bones) bones = ReadPointer(mesh, Offsets::StaticMesh + 0x10);
	if (!bones) {
		return FALSE;
	}

	float compMatrix[4][4] = { 0 };
	ToMatrixWithScale(reinterpret_cast<float*>(reinterpret_cast<PBYTE>(mesh) + Offsets::ComponentToWorld), compMatrix);

	if (Settings.AimPos == 1)
		GetBoneLocation(compMatrix, bones, 66, &out.X);
	else if (Settings.AimPos == 2)
		GetBoneLocation(compMatrix, bones, 5, &out.X);
	else if (Settings.AimPos == 3)
		GetBoneLocation(compMatrix, bones, 2, &out.X);
	else // which is impossible.
		GetBoneLocation(compMatrix, bones, 66, &out.X);
	return TRUE;
}

FVector* GetPawnRootLocationA(PVOID pawn) {
	auto root = ReadPointer(pawn, Offsets::RootComponent);
	if (!root) {
		return nullptr;
	}

	return reinterpret_cast<FVector*>(reinterpret_cast<PBYTE>(root) + Offsets::RelativeLocation);
}

bool isMovingKeys() {
	if (o_getasynckeystate(0x5A) == -32767 ||
		o_getasynckeystate(0x53) == -32767 ||
		o_getasynckeystate(0x51) == -32767 ||
		o_getasynckeystate(0x51) == -32767 ||
		o_getasynckeystate(0x44) == -32767 ||
		o_getasynckeystate((DWORD)VK_SPACE) == -32767)
		return true;

	return false;
}
namespace ImGui {
	void PushFontShadow(unsigned int col);
};

namespace utils {
	void DrawNewText(int x, int y, int R, int G, int B, int A, const char* str);
}

void boatCrazyBoost() {
	if (!TargetBoat) return;
	utils::DrawNewText(10, 10, 255, 0, 255, 255, "TargetBoat = True");
	auto SceneComponent = ReadPointer(TargetBoat, Offsets::RootComponent);
	if (!SceneComponent) return;
	utils::DrawNewText(10, 20, 255, 0, 255, 255, "SceneComponent = True");
	auto MeatballVehicleConfigs = ReadPointer(TargetBoat, Offsets::FortMeatballVehicleConfigsClass);
	if (!MeatballVehicleConfigs) return;
	utils::DrawNewText(10, 30, 255, 0, 255, 255, "MeatballVehicleConfigs = True");
	
	if (Settings.BoatBoost)
	{
		utils::DrawNewText(10, 40, 255, 0, 255, 255, "Settings.BoatBoost = True");
		(*(FLOAT*)(((PBYTE)MeatballVehicleConfigs + Offsets::BoostMinPushForce))) = (1200.0f * Settings.BoatBoostMultiplier);
		(*(FLOAT*)(((PBYTE)MeatballVehicleConfigs + Offsets::BoostTopSpeedForceMultiplier))) = (1.3f * Settings.BoatBoostMultiplier);
		(*(FLOAT*)(((PBYTE)MeatballVehicleConfigs + Offsets::BoostTopSpeedMultiplier))) = (1.3f * Settings.BoatBoostMultiplier);
		(*(FLOAT*)(((PBYTE)MeatballVehicleConfigs + Offsets::LandTopSpeedMultiplier))) = (1.0f * Settings.BoatBoostMultiplier);
		(*(FLOAT*)(((PBYTE)MeatballVehicleConfigs + Offsets::LandPushForceMultiplier))) = (3.0f * Settings.BoatBoostMultiplier);
		(*(FLOAT*)(((PBYTE)MeatballVehicleConfigs + Offsets::BoostSteeringMultiplier))) = 1.0f;
		(*(FLOAT*)(((PBYTE)MeatballVehicleConfigs + Offsets::LandSteeringMultiplier))) = 1.0f;
		(*(FLOAT*)(((PBYTE)MeatballVehicleConfigs + Offsets::LandMinSpeedSteeringAngle))) = 180.0f;
		(*(FLOAT*)(((PBYTE)MeatballVehicleConfigs + Offsets::LandMaxSpeedSteeringAngle))) = 180.0f;
		utils::DrawNewText(10, 50, 255, 0, 255, 255, "Super boost success = True");
	}
	
	else
	{
		(*(FLOAT*)(((PBYTE)MeatballVehicleConfigs + Offsets::BoostMinPushForce))) = 1200;
		(*(FLOAT*)(((PBYTE)MeatballVehicleConfigs + Offsets::BoostTopSpeedForceMultiplier))) = 1.29;
		(*(FLOAT*)(((PBYTE)MeatballVehicleConfigs + Offsets::BoostTopSpeedMultiplier))) = 1.29;
		(*(FLOAT*)(((PBYTE)MeatballVehicleConfigs + Offsets::LandTopSpeedMultiplier))) = 0.1;
		(*(FLOAT*)(((PBYTE)MeatballVehicleConfigs + Offsets::LandPushForceMultiplier))) = 3;
		(*(FLOAT*)(((PBYTE)MeatballVehicleConfigs + Offsets::BoostSteeringMultiplier))) = 0.2;
		(*(FLOAT*)(((PBYTE)MeatballVehicleConfigs + Offsets::LandSteeringMultiplier))) = 1;
		(*(FLOAT*)(((PBYTE)MeatballVehicleConfigs + Offsets::LandMinSpeedSteeringAngle))) = 180;
		(*(FLOAT*)(((PBYTE)MeatballVehicleConfigs + Offsets::LandMaxSpeedSteeringAngle))) = 25;
	}
}

void PEexploits() {
	boatCrazyBoost();
}


struct
{
	struct FVector DestLocation;
	struct FRotator DestRotation;
	bool ReturnValue;
} param;


bool CanProceedToPE() {
	if (!entityx)
		return false;

	if (!LocalPawn)
		return false;

	if (!read<uint64_t>(entityx + Offsets::RootComponent))
	{
		entityx = 0;
		return false;
	}
	if (!read<uint64_t>(entityx + Offsets::PlayerState))
	{
		entityx = 0;
		return false;
	}
	if (!read<uint64_t>(entityx + Offsets::Mesh))
	{
		entityx = 0;
		return false;
	}
	uint8_t bIsDying = *(uint8_t*)(entityx + Offsets::bIsDying);
	if (BIT_CHECK(bIsDying, 3))
	{
		entityx = 0;
		return false;
	}

	if (!PlayerController || !read<uintptr_t>(PlayerController))
	{
		entityx = 0;
		return false;
	}
}

FMinimalViewInfo& GetViewInfo();
Vector3 inline LimitRotation(Vector3 startRotation, Vector3 endRotation);
char SetIgnoreLookInput = (char)0;

PVOID(*UEvent)(PVOID, PVOID, PVOID, PVOID) = nullptr;
PVOID UPEx(UObject* obj, UObject* function, PVOID params, PVOID result) {
	return UEvent(obj, function, params, result);
}

INT(*GetViewPoint)(PVOID, FMinimalViewInfo*, BYTE) = nullptr;
INT GetViewPointHook(PVOID player, FMinimalViewInfo* viewInfo, BYTE stereoPass)
{
	auto ret = GetViewPoint(player, viewInfo, stereoPass);

	CamLoc = viewInfo->Location;
	CamRot = viewInfo->Rotation;


	if (Settings.FOVChanger)
	{
		viewInfo->FOV = (float)Settings.FOV;
	}

	GlobalFOV = viewInfo->FOV;
	return ret;
}


bool wasClicked = false;
void Exploits() {
	if (!LocalPawn) return;
	auto weaponName = GetObjects::GetObjectFirstName((UObject*)LocalWeapon);

	if (Settings.AirStuck) {
		if (spoof_call(game_rbx_jmp, GetAsyncKeyState, Settings.AirStuckKey)) {
			(*(FLOAT*)(((PBYTE)LocalPawn + Offsets::CustomTimeDilation))) = 0.01;
			wasClicked = true;
		}
		else {
			if (wasClicked) {
				(*(FLOAT*)(((PBYTE)LocalPawn + Offsets::CustomTimeDilation))) = 1;
				wasClicked = false;
			}
		}
	}
	else {
		if (wasClicked) {
			(*(FLOAT*)(((PBYTE)LocalPawn + Offsets::CustomTimeDilation))) = 1;
			wasClicked = false;
		}
	}

	/*
	if (Settings.InstantReload && LocalPawn) {

		static float last_fire_ability_time = 0.f;
		localPlayerWeapon = ReadPointer(LocalPawn, Offsets::CurrentWeapon);
		auto stats = GetWeaponStats(localPlayerWeapon);

		auto& reloadTime = *reinterpret_cast<float*>(reinterpret_cast<PBYTE>(stats) + Offsets::FortBaseWeaponStats::ReloadTime);
		auto& ReloadScale = *reinterpret_cast<float*>(reinterpret_cast<PBYTE>(stats) + Offsets::FortBaseWeaponStats::ReloadScale);
		auto& ChargeDownTime = *reinterpret_cast<float*>(reinterpret_cast<PBYTE>(stats) + Offsets::FortBaseWeaponStats::ChargeDownTime);

		if (GetWeaponStats(localPlayerWeapon) != nullptr)
		{
			if (Spoofer::SpoofCall(GetAsyncKeyState, 'Q' & 0x0001)) {
				return;
			}
			if (stats) {
				if (reloadTime != 0.01f && *(float*)(LocalWeapon + Offsets::LastFireAbilityTime) == last_fire_ability_time) {
					last_fire_ability_time = *(float*)(LocalWeapon + Offsets::LastFireAbilityTime);
					originalReloadTime = reloadTime;
					originalReloadScale = ReloadScale;
					originalChargeDownTime = ChargeDownTime;

					reloadTime = 0.0f;
					ReloadScale = 0.0f;
					ChargeDownTime = 0.1f;
				}
				else if (reloadTime = 0.0f && *(float*)(LocalWeapon + Offsets::LastFireAbilityTime) != last_fire_ability_time) {
					{
						last_fire_ability_time = *(float*)(LocalWeapon + Offsets::LastFireAbilityTime);
						reloadTime = originalReloadTime;
						ReloadScale = originalReloadScale;
						ChargeDownTime = originalChargeDownTime;
						return;
					}
				}
			}
		}
	}*/
	/*
	if (bNoRecoil && LocalPawn) {

		static float last_fire_ability_time = 0.f;
		localPlayerWeapon = ReadPointer(LocalPawn, Offsets::CurrentWeapon);
		auto stats = GetWeaponStats(localPlayerWeapon);

		auto& RecoilVert = *reinterpret_cast<float*>(reinterpret_cast<PBYTE>(stats) + Offsets::RecoilVert);
		auto& RecoilHoriz = *reinterpret_cast<float*>(reinterpret_cast<PBYTE>(stats) + Offsets::RecoilHoriz);
		auto& RecoilDownsightsMultiplier = *reinterpret_cast<float*>(reinterpret_cast<PBYTE>(stats) + Offsets::RecoilDownsightsMultiplier);

		if (GetWeaponStats(localPlayerWeapon) != nullptr)
		{
			if (Spoofer::SpoofCall(GetAsyncKeyState, 'Q' & 0x0001)) {
				return;
			}
			if (stats)
			{
				if (*(float*)(LocalWeapon + Offsets::LastFireAbilityTime) != last_fire_ability_time) {
					last_fire_ability_time = *(float*)(LocalWeapon + Offsets::LastFireAbilityTime);

					originalRecoilVert = RecoilVert;
					originalRecoilHoriz = RecoilHoriz;
					originalRecoilDownsightsMultiplier = RecoilDownsightsMultiplier;

					RecoilVert = 0.0f;
					RecoilHoriz = 0.0f;
					RecoilDownsightsMultiplier = 0.0f;

				}

			}
		}
		else if (*(float*)(LocalWeapon + Offsets::LastFireAbilityTime) == last_fire_ability_time) {
			last_fire_ability_time = *(float*)(LocalWeapon + Offsets::LastFireAbilityTime);

			RecoilVert = originalRecoilVert;
			RecoilHoriz = originalRecoilHoriz;
			RecoilDownsightsMultiplier = originalRecoilDownsightsMultiplier;
			return;
		}
	}*/
	






	if (Settings.NoSpreadAimbot) {
	
		static float last_fire_ability_time = 0.f;
		localPlayerWeapon = ReadPointer(LocalPawn, Offsets::CurrentWeapon);
		auto stats = GetWeaponStats(localPlayerWeapon);
	
		auto& Spread = *reinterpret_cast<float*>(reinterpret_cast<PBYTE>(stats) + Offsets::Spread);
		auto& SpreadDownsights = *reinterpret_cast<float*>(reinterpret_cast<PBYTE>(stats) + Offsets::SpreadDownsights);
		auto& StandingStillSpreadMultiplier = *reinterpret_cast<float*>(reinterpret_cast<PBYTE>(stats) + Offsets::StandingStillSpreadMultiplier);
	
		if (GetWeaponStats(localPlayerWeapon) != nullptr)
		{
			if (Spoofer::SpoofCall(GetAsyncKeyState, 'Q' & 0x0001)) {
				return;
			}
			if (stats) {
				if (Spread != 0.01f && *(float*)(LocalWeapon + Offsets::Spread) == last_fire_ability_time) {
					last_fire_ability_time = *(float*)(LocalWeapon + Offsets::SpreadDownsights);
					originalSpread = Spread;
					originalSpreadDownsights = SpreadDownsights;
					originalStandingStillSpreadMultiplier = StandingStillSpreadMultiplier;
	
					Spread = 0.1f;
					SpreadDownsights = 0.1f;
					StandingStillSpreadMultiplier = 0.1f;
				}
				else if (Spread = 0.0f && *(float*)(LocalWeapon + Offsets::Spread) != last_fire_ability_time) {
					{
						last_fire_ability_time = *(float*)(LocalWeapon + Offsets::LastFireAbilityTime);
						Spread = originalSpread;
						SpreadDownsights = originalSpreadDownsights;
						StandingStillSpreadMultiplier = originalStandingStillSpreadMultiplier;
						return;
						(Spread = 0.0f && *(float*)(LocalWeapon + Offsets::AthenaCrouchingSpreadMultiplier) != last_fire_ability_time);
					}
				}
			}
		}
	}


	if (Settings.NoSpreadAimbot && LocalPawn) {
	
		static float last_fire_ability_time = 0.f;
		localPlayerWeapon = ReadPointer(LocalPawn, Offsets::CurrentWeapon);
		auto stats = GetWeaponStats(localPlayerWeapon);
	
		auto& Spread = *reinterpret_cast<float*>(reinterpret_cast<PBYTE>(stats) + Offsets::Spread);
		auto& SpreadDownsights = *reinterpret_cast<float*>(reinterpret_cast<PBYTE>(stats) + Offsets::SpreadDownsights);
		auto& StandingStillSpreadMultiplier = *reinterpret_cast<float*>(reinterpret_cast<PBYTE>(stats) + Offsets::StandingStillSpreadMultiplier);
		auto& AthenaJumpingFallingSpreadMultiplier = *reinterpret_cast<float*>(reinterpret_cast<PBYTE>(stats) + Offsets::AthenaJumpingFallingSpreadMultiplier);
		auto& AthenaCrouchingSpreadMultiplier = *reinterpret_cast<float*>(reinterpret_cast<PBYTE>(stats) + Offsets::AthenaCrouchingSpreadMultiplier);
		auto& AthenaSprintingSpreadMultiplier = *reinterpret_cast<float*>(reinterpret_cast<PBYTE>(stats) + Offsets::AthenaSprintingSpreadMultiplier);
		auto& MinSpeedForSpreadMultiplier = *reinterpret_cast<float*>(reinterpret_cast<PBYTE>(stats) + Offsets::MinSpeedForSpreadMultiplier);
		auto& MaxSpeedForSpreadMultiplier = *reinterpret_cast<float*>(reinterpret_cast<PBYTE>(stats) + Offsets::MaxSpeedForSpreadMultiplier);
	
		if (GetWeaponStats(localPlayerWeapon) != nullptr)
		{
			if (Spoofer::SpoofCall(GetAsyncKeyState, 'Q' & 0x0001)) {
				return;
			}
			if (stats)
			{
				if (Spread != 0.01f && *(float*)(LocalWeapon + Offsets::LastFireAbilityTime) != last_fire_ability_time) {
	
					last_fire_ability_time = *(float*)(LocalWeapon + Offsets::LastFireAbilityTime);
					originalSpread = Spread;
					originalSpreadDownsights = SpreadDownsights;
					originalStandingStillSpreadMultiplier = StandingStillSpreadMultiplier;
					originalAthenaJumpingFallingSpreadMultiplier = AthenaJumpingFallingSpreadMultiplier;
					originalAthenaCrouchingSpreadMultiplier = AthenaCrouchingSpreadMultiplier;
					originalAthenaSprintingSpreadMultiplier = AthenaSprintingSpreadMultiplier;
					originalMinSpeedForSpreadMultiplier = MinSpeedForSpreadMultiplier;
					originalMaxSpeedForSpreadMultiplier = MaxSpeedForSpreadMultiplier;
	
					Spread = 0.0f;
					SpreadDownsights = 0.0f;
					StandingStillSpreadMultiplier = 0.0f;
				}
	
			}
		}
		else if (Spread = 0.0f && *(float*)(LocalWeapon + Offsets::LastFireAbilityTime) == last_fire_ability_time) {
	
			last_fire_ability_time = *(float*)(LocalWeapon + Offsets::LastFireAbilityTime);
			Spread = originalSpread;
			SpreadDownsights = originalSpreadDownsights;
			StandingStillSpreadMultiplier = originalStandingStillSpreadMultiplier;
			AthenaJumpingFallingSpreadMultiplier = originalAthenaJumpingFallingSpreadMultiplier;
			AthenaCrouchingSpreadMultiplier = originalAthenaCrouchingSpreadMultiplier;
			AthenaSprintingSpreadMultiplier = originalAthenaSprintingSpreadMultiplier;
			MinSpeedForSpreadMultiplier = originalMinSpeedForSpreadMultiplier;
			MaxSpeedForSpreadMultiplier = originalMaxSpeedForSpreadMultiplier;
	
			return;
		}
	}
	if (Settings.NoSpreadAimbot)
	{
	
		uint8_t curweap = 0;
		uint64_t v10 = 0;
		int v11;
		int v25;
		if (!LocalPawn) return;
		curweap = *(uint8_t*)((uintptr_t)LocalPawn + 0x5A0);
		if (curweap) return;
		v10 = *(uint64_t*)(curweap + 0xE6E);
		if (!v10) printf("\nv10 is incorrect."); return;
		v11 = *(int*)(curweap + 0xE6F);
		if (!v11) printf("\nv11 is incorrect.");  return;
		v25 = v11 ^ curweap + ((4 * v10) + 0xE5E);
		if (!v25) printf("\nv25 is incorrect."); return;
		*(float*)v25 = 0.0;
	}

	if (Settings.NoSpreadAimbot) {
		SetCurrentSpread(LocalWeapon, (float)0.101);
	}
	if (Settings.RapidFire && LocalPawn) {
		Rapid((float)4);
	}
}
